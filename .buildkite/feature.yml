# This is the feature branch pipeline. It does not update any infrastructure, but instead
# performs sanity checks of the templates to verify that they meet minimum standards.

env:
  # Ensure all jobs use these values from the agent environment
  WEBCMS_ENVIRONMENT: ${WEBCMS_ENVIRONMENT}
  WEBCMS_SITE: ${WEBCMS_SITE}
  WEBCMS_IMAGE_TAG: ${WEBCMS_IMAGE_TAG}
  WEBCMS_REPO_URL: ${WEBCMS_REPO_URL}

steps:
  # This grouped step builds all Docker images used in the ECS cluster: Drupal,
  # Drush, nginx, and the FPM metrics sidecar.
  - group: ":docker: Build images"
    steps:
      # Iterate over each production build target in services/drupal/Dockerfile.
      # Further reading: https://buildkite.com/docs/pipelines/build-matrix
      - label: "Build {{matrix}}"
        matrix:
          - drupal
          - nginx
          - drush

        # Use the more powerful Docker builder agent pool
        agents:
          queue: docker-builders-arm

        # This concurrency group is shared with the fpm-metrics container build
        # below this step.
        concurrency_group: $BUILDKITE_PIPELINE_SLUG/build-$BUILDKITE_BRANCH
        concurrency: 4

        # Make the matrix value available as an environment variable. Buildkite
        # does not interpolate this in plugin arguments, so we have to do that
        # here.
        env:
          TARGET: '{{matrix}}'

        plugins:
          # Save a Composer authentication file (see [1]) in order to avoid
          # GitHub rate limits.
          #
          # [1]: https://getcomposer.org/doc/articles/authentication-for-private-packages.md#authentication-in-auth-json-per-project
          - seek-oss/aws-sm#v2.3.1:
              file:
                - path: services/drupal/auth.json
                  secret-id: forumone/composer-auth

          # Assume cross-account build role. We don't log in directly to ECR as Kaniko is able
          # to do that for us.
          - cultureamp/aws-assume-role#v0.1.0:
              role: arn:aws:iam::316981092358:role/BuildkiteRoleForImageBuilds

          # Execute a Kaniko-powered build.
          - docker#v3.12.0:
              # Use the debug tag of the Kaniko executor: this gives us access
              # to /bin/sh (which we need to generate Kaniko's config.json).
              image: gcr.io/kaniko-project/executor:debug
              workdir: /workspace

              # Forward AWS the authentication tokens we generated with the aws-assume-role plugin
              propagate-aws-auth-tokens: true

              # Forward the $TARGET environment variable (i.e., the value of '{{matrix}}')
              environment:
                - TARGET

              # Some notes on the build script:
              # 1. We generate Kaniko's config.json to allow it to log in to AWS
              #    ECR.
              # 2. Kaniko build caching is enabled. Intermediate layers are
              #    pushed to a cache repository in ECR. Subsequent builds can
              #    query the cache instead of re-executing more expensive build
              #    steps.
              # 3. The snapshot mode is set to "redo" instead of "full". This
              #    uses cheaper but less accurate metadata for FS snapshots. We
              #    assume this won't cause any issues for us, as any changes in
              #    composer.json will have an outsized change in the contents of
              #    the vendor and contrib directories, which should sufficiently
              #    disrupt the redo snapshot information.
              # 4. We use Kaniko's (experimental) system to determine if a RUN
              #    command needs to be re-run. Allegedly this improves build
              #    performance by a significant degree.
              # 5. We use Buildkite's commit and tag variables to save to the
              #    GIT_COMMIT and GIT_TAG build args.
              # 6. For feature branch builds, we do not push the final image.
              #
              # Note that in this script, ${FOO} is interpolated by the
              # Buildkite agent, whereas $$FOO is translated to $FOO later: this
              # means that the Kaniko shell will see the different values of
              # $TARGET, as generated by the matrix.
              #
              # See the Kaniko README for more information on the flags:
              # https://github.com/GoogleContainerTools/kaniko#readme
              entrypoint: /bin/sh
              command:
                - -ec
                - |
                    echo '{"credsStore":"ecr-login"}' >/kaniko/.docker/config.json
                    /kaniko/executor \
                      --context=/workspace/services/drupal \
                      --cache \
                      --cache-repo="${WEBCMS_REPO_URL}/webcms-${WEBCMS_ENVIRONMENT}-cache" \
                      --skip-unused-stages \
                      --snapshot-mode=redo \
                      --use-new-run \
                      --build-arg GIT_TAG="$BUILDKITE_TAG" \
                      --build-arg GIT_COMMIT="$BUILDKITE_COMMIT" \
                      --build-arg WEBCMS_SITE="$WEBCMS_SITE" \
                      --target="$$TARGET" \
                      --no-push

  # Perform a Terraform formatting check. See the terraform-fmt.sh script for more details
  # on what is executed in this step.
  - label: ":terraform: Formatting"
    plugins:
      - docker#v3.12.0:
          image: hashicorp/terraform:0.14.9
          entrypoint: /bin/sh
          command: [.buildkite/terraform-fmt.sh]

  # For feature branches, we plan three modules: network, infrastructure, and webcms. This
  # way, all branches can be evaluated for their potential impact on existing
  # infrastructure. These plans can all be executed in parallel, meaning that they should
  # have only a minimal impact on build time.

  - label: ":pipeline: :terraform: network"
    commands:
      # Prevent WEBCMS_SITE from creating multiple concurrency groups for this
      # Terraform plan run.
      - unset WEBCMS_SITE
      - buildkite-agent pipeline upload .buildkite/terraform.plan.yml
    env:
      WEBCMS_SSM_NAMESPACE: /terraform/${WEBCMS_ENVIRONMENT}/network
      WEBCMS_TF_MODULE: network

  - label: ":pipeline: :terraform: infrastructure"
    commands:
      - unset WEBCMS_SITE
      - buildkite-agent pipeline upload .buildkite/terraform.plan.yml
    env:
      WEBCMS_SSM_NAMESPACE: /terraform/${WEBCMS_ENVIRONMENT}/infrastructure
      WEBCMS_TF_MODULE: infrastructure

  # We arbitrarily choose English for a Terraform plan. The two sites' configurations
  # should not be so different that this will miss subtleties with Spanish-language
  # deployments.
  - label: ":pipeline: :terraform: webcms"
    command: buildkite-agent pipeline upload .buildkite/terraform.plan.yml
    env:
      WEBCMS_SSM_NAMESPACE: /terraform/${WEBCMS_ENVIRONMENT}/${WEBCMS_SITE}/en
      WEBCMS_TF_MODULE: webcms
      WEBCMS_LANG: en
