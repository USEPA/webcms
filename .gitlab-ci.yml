# WebCMS GitLab CI/CD Pipeline Configuration
# Orchestrates complete deployment pipeline for EPA WebCMS Drupal application.
# Handles infrastructure provisioning, Docker builds, security scanning, and deployments.
# See docs/cicd-pipeline.md for detailed documentation.

stages:
  # Docker Image Builds (all branches) - Build first to enable testing
  - Build                             # Build application Docker images (drupal, nginx, drush)

  # Security Scanning (live branch only - stage deployments)
  - Test                              # Run SAST, dependency scanning, secret detection
  - Scan                              # Prisma Cloud image vulnerability scanning

  # Infrastructure Provisioning (live branch only)
  - Infrastructure:Preprod:Init       # Initialize Terraform backend and providers
  - Infrastructure:Preprod:Validate   # Validate Terraform configuration syntax
  - Infrastructure:Preprod:Plan       # Generate Terraform execution plan
  - Infrastructure:Preprod:Apply      # Apply infrastructure changes (manual approval required)

  # Production Deployment (live branch → WEBCMS_SITE: dev)
  - Deploy:Dev:Init                   # Initialize production deployment (English + Spanish parallel)
  - Deploy:Dev:Validate               # Validate production Terraform config (English + Spanish parallel)
  - Deploy:Dev:Plan                   # Plan production deployment (English + Spanish parallel)
  - Deploy:Dev:Apply                  # Apply production deployment (English + Spanish parallel)

  # Staging Deployment (staging branch → WEBCMS_SITE: stage)
  - Deploy:Stage:Init                 # Initialize staging deployment (English + Spanish parallel)
  - Deploy:Stage:Validate             # Validate staging Terraform config (English + Spanish parallel)
  - Deploy:Stage:Plan                 # Plan staging deployment (English + Spanish parallel)
  - Deploy:Stage:Apply                # Apply staging deployment (English + Spanish parallel)

  # Database Updates (Drush operations via ECS tasks)
  - Update                            # Run Drush updates for all sites (parallel by site/language)

  # Release Management (create artifacts after successful deployment)
  - Artifacts                         # Create deployment artifacts
  - Release                           # Create GitLab releases

# Workflow Rules - Control when pipelines are created
# Ensures pipelines run for mirror updates from GitHub
workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push"'        # Run on push (includes mirror updates)
    - if: '$CI_PIPELINE_SOURCE == "web"'         # Run on manual trigger via UI
    - if: '$CI_PIPELINE_SOURCE == "api"'         # Run on API trigger
    - if: '$CI_PIPELINE_SOURCE == "trigger"'     # Run on pipeline trigger
    - if: '$CI_PIPELINE_SOURCE == "schedule"'    # Run on scheduled pipelines
    - if: '$CI_COMMIT_TAG'                       # Run on tag creation
    - when: never                                 # Don't run for any other sources

# Global Pipeline Configuration
# Our GitLab runner environment is Docker-based, so we apply this tag to every step.
default:
  tags:
    - docker

  # Global caching strategy (fallback/shared cache across all jobs):
  # More specific caches are defined in templates and override this:
  # - Terraform: Lines 116-123 (cached by module + .terraform.lock.hcl for provider binaries)
  # - Composer:  Lines 335-340 (cached by branch for PHP dependencies in Drupal builds)
  # - npm:       Lines 270-278 (cached by ci/package-lock.json for Drush automation)
  cache:
    key: global-$CI_COMMIT_REF_SLUG
    paths:
      - .gitlab-ci-cache/  # General-purpose cache directory for miscellaneous artifacts

# Define this variable once here and allow it to cascade down into jobs and child
# pipelines. Creates unique image tags based on branch and commit for reproducible builds.
variables:
  WEBCMS_IMAGE_TAG: $CI_COMMIT_REF_SLUG-$CI_COMMIT_SHA
  # Control dev deployment from live branch
  # Set DEPLOY_TO_DEV=true when manually triggering pipeline to also deploy to dev site
  # By default, live branch only deploys to stage
  DEPLOY_TO_DEV: "false"
  # Skip Docker image builds and reuse existing :development-latest images
  # Set SKIP_BUILD=true to deploy code changes without rebuilding containers
  # Useful for rapid iteration when only Drupal PHP/config files changed
  SKIP_BUILD: "false"

# Include GitLab's built-in security scanning templates for comprehensive security testing
# and Microsoft Teams notifications for pipeline events
include:
  - template: Jobs/SAST.gitlab-ci.yml              # Static Application Security Testing
  - template: Jobs/Dependency-Scanning.gitlab-ci.yml  # Scan for vulnerable dependencies
  - template: Jobs/Secret-Detection.gitlab-ci.yml     # Detect exposed secrets in code
  - local: .gitlab/teams-notifications.yml            # Microsoft Teams webhook notifications

# Override stage for GitLab-provided security scanning jobs to use capitalized stage names
# and restrict to live branch only (stage deployments)
sast:
  stage: Test
  rules:
    - if: '$CI_COMMIT_BRANCH == "live"'  # Only run on live branch
    - when: never  # Explicitly never run otherwise

dependency_scanning:
  stage: Test
  rules:
    - if: '$CI_COMMIT_BRANCH == "live"'  # Only run on live branch
    - when: never  # Explicitly never run otherwise

secret_detection:
  stage: Test
  rules:
    - if: '$CI_COMMIT_BRANCH == "live"'  # Only run on live branch
    - when: never  # Explicitly never run otherwise

# Override all SAST sub-jobs to prevent them from running on development branch
semgrep-sast:
  rules:
    - if: '$CI_COMMIT_BRANCH == "live"'
    - when: never

gemnasium-dependency_scanning:
  rules:
    - if: '$CI_COMMIT_BRANCH == "live"'
    - when: never

#region Templates
# Reusable job templates that provide common configuration for pipeline jobs.
# Concrete jobs extend these templates and override variables/stages as needed.

# Base Terraform Template (.terraform)
# Provides common configuration for all Terraform jobs:
# - Terraform CLI image and automation settings
# - Variable mapping from GitLab to Terraform conventions
# - Provider caching for faster builds
# - Backend configuration setup
.terraform:
  image:
    name: registry.gitlab.com/gitlab-org/terraform-images/releases/0.14:latest
    entrypoint: ['']

  variables:
    # Derive the root from the project directory and module name
    TF_ROOT: $CI_PROJECT_DIR/terraform/$TF_MODULE

    # Tell Terraform we are running in automation and should fail if it finds missing inputs
    # instead of attempting to read from the console.
    TF_INPUT: '0'
    TF_IN_AUTOMATION: '1'

    # Proxy input variables from our convention to variables recognizable by Terraform. We
    # can do this unconditionally because Terraform only inspects the environment when it
    # sees a declaration, sparing us from spurious warnings about values for undeclared
    # variables.
    TF_VAR_environment: ${WEBCMS_ENVIRONMENT}
    TF_VAR_site: ${WEBCMS_SITE}
    TF_VAR_lang: ${WEBCMS_LANG}
    TF_VAR_image_tag: ${WEBCMS_IMAGE_TAG}
    TF_VAR_aws_region: ${AWS_REGION}

  # Enhanced caching strategy for Terraform:
  # - Cache by module and branch for provider binaries
  # - Cache by commit for plan artifacts
  # - Separate cache for different environments to avoid conflicts
  cache:
    key: 
      files:
        - terraform/${TF_MODULE}/.terraform.lock.hcl
      prefix: tf-${TF_MODULE}-${CI_COMMIT_REF_SLUG}
    paths:
      - ${TF_ROOT}/.terraform
      - ${TF_ROOT}/.terraform.lock.hcl

  # Every job begins execution in the module's root directory with:
  # 1. An empty http backend configuration to be filled in by the gitlab-terraform helper,
  #    and
  # 2. A copy of the GitLab-injected TERRAFORM_TFVARS file variable. (This variable is a
  #    reference to a path in a temporary directory, so we copy it in order to allow
  #    Terraform to see it automatically.)
  #
  # Note: The gitlab-terraform helper automatically runs init as needed, so init stages
  # are the only jobs that should explicitly call `gitlab-terraform init`.
  before_script:
    - cd $TF_ROOT
    - cp $backend_tf backend.tf
    - cp "$TERRAFORM_TFVARS" terraform.tfvars

# Terraform Initialization Template (.init)
# Initializes Terraform backend and downloads provider plugins.
# This template is extended by concrete infrastructure jobs that set TF_MODULE and other variables.
# The init process configures the GitLab-managed HTTP backend for remote state storage.
#
# Note: This is the ONLY stage that should explicitly call `gitlab-terraform init`.
# All subsequent stages (validate, plan, apply) rely on cached initialization.
.init:
  extends: .terraform
  stage: Infrastructure:Preprod:Init

  script:
    - gitlab-terraform init -upgrade  # Update provider versions to match lock file
    - gitlab-terraform init            # Initialize backend and download providers

# Terraform Validation Template (.validate)
# Validates Terraform configuration syntax and checks for logical errors.
# This template is extended by concrete jobs that add explicit 'needs' dependencies on init jobs.
# Validation runs independently for each module/environment combination.
.validate:
  extends: .terraform
  stage: Infrastructure:Preprod:Validate

  script:
    - gitlab-terraform validate  # Validate configuration syntax and internal consistency

# Terraform Planning Template (.plan)
# Generates execution plan showing what infrastructure changes will be applied.
# This template is extended by concrete jobs that add explicit 'needs' dependencies on validate jobs.
# Creates both binary plan cache (for apply) and JSON report (for GitLab MR integration).
.plan:
  extends: .terraform
  stage: Infrastructure:Preprod:Plan

  script:
    - gitlab-terraform plan       # Generate binary execution plan
    - gitlab-terraform plan-json  # Generate JSON plan for GitLab integration

  artifacts:
    name: plan  # Generic name; concrete jobs should override with semantic naming
    paths:
      - $TF_ROOT/plan.cache  # Binary plan file used by apply jobs
    reports:
      terraform: $TF_ROOT/plan.json  # JSON plan displayed in GitLab MR widget

# Terraform Apply Template (.apply)
# Executes the Terraform plan to apply infrastructure changes.
# This template is extended by concrete jobs that add explicit 'needs' and 'dependencies' on plan jobs.
# Includes safety rules to prevent unauthorized deployments to production AWS resources.
.apply:
  extends: .terraform
  stage: Infrastructure:Preprod:Apply  # Note: Concrete jobs override this for environment-specific stages

  # Concrete jobs must specify dependencies to download plan artifacts from the corresponding plan job.
  # Template cannot specify this generically as job names vary by environment.
  dependencies: []  # Placeholder; override in concrete jobs

  script:
    - gitlab-terraform apply  # Execute the cached plan without re-planning

  # Safety rules to control when infrastructure changes can be applied.
  # These rules provide defense-in-depth against accidental deployments.
  #
  # Rule evaluation uses "first match wins" logic:
  # 1. Infrastructure module changes require manual approval on main/live branches
  #    (prevents accidental changes to VPC, ECS clusters, load balancers, etc.)
  # 2. WebCMS module changes (ECS task definitions, service configs) run automatically
  #    on integration/main/live branches as they are lower-risk and frequently updated
  # 3. All other scenarios are denied by default (safety net for misconfigurations)
  rules:
    - if: >-
        $TF_MODULE == "infrastructure" &&
        ($CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "live")
      when: manual  # Require human approval for core infrastructure changes

    - if: >-
        $TF_MODULE == "webcms" &&
        ($CI_COMMIT_BRANCH == "integration" || $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "live")
      when: on_success  # Auto-apply application deployment changes

    - when: never  # Deny all other apply attempts (safety net)

# Job Template Definitions
# These templates provide reusable configurations for different types of pipeline jobs.
# Each template extends the base .terraform template and adds specific functionality.

# Infrastructure Template (.infrastructure)
# Handles AWS infrastructure provisioning using the terraform/infrastructure module
# Creates VPC, ECS cluster, load balancers, S3 buckets, and other shared resources
.infrastructure:
  extends: .terraform
  tags:
    - docker
  variables:
    TF_MODULE: infrastructure
    TF_ADDRESS: ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/dev

# Build Template (.build)
# Triggers child pipeline for Docker image building using Kaniko
# Builds Drupal, Nginx, Drush, and metrics container images
.build:
  stage: Build

  trigger:
    include: .gitlab/docker.yml
    strategy: depend

# Deploy Template (.deploy)
# Manages ECS service and task definition deployments using terraform/webcms module
# Updates application infrastructure per site/language combination
.deploy:
  stage: deploy
  extends: .terraform
  tags:
    - docker

  variables:
    TF_MODULE: webcms
    TF_ADDRESS: ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/${WEBCMS_SITE}-webcms-$WEBCMS_LANG

# Update Template (.update)
# Runs Drush database maintenance operations via ECS task invocation after deployments.
# Executes operations like database updates (drush updb), config import (drush cim),
# and cache clearing on the deployed Drupal environment.
#
# Uses Node.js 18 (current LTS) to run the ci/drush.js automation script which:
# - Invokes ECS RunTask API to execute Drush commands in the drush container
# - Streams CloudWatch logs back to the pipeline for visibility
# - Reports success/failure based on task exit code
.update:
  stage: Update  # All update jobs run in parallel within this stage

  # Node.js 18 LTS (Alpine variant for smaller image size)
  image:
    name: node:18-alpine
    entrypoint: ['']  # Override entrypoint to allow direct command execution

  script:
    - cd $CI_PROJECT_DIR/ci
    - npm ci --production --prefer-offline --cache .npm  # Install AWS SDK and dependencies
    - node drush.js  # Execute Drush automation via ECS RunTask API

  # Cache npm dependencies using package-lock.json for precise invalidation.
  # Significantly speeds up update jobs by avoiding repeated package downloads.
  cache:
    key:
      files:
        - ci/package-lock.json  # Cache invalidates only when dependencies change
      prefix: npm-drush
    paths:
      - ci/node_modules/  # Cached installed packages
      - ci/.npm           # npm's internal cache
    policy: pull-push    # Both read and write cache (first job creates, others reuse)

# Environment-Specific Deployment Templates
# These templates reduce duplication by providing common configurations for each deployment environment

# Dev Site Template (development branch → WEBCMS_SITE: dev)
# Also deploys from live branch when DEPLOY_TO_DEV=true
# Requires manual approval for infrastructure changes, automatic for application updates
.deploy:production:
  extends: .deploy
  variables:
    WEBCMS_ENVIRONMENT: preproduction
    WEBCMS_SITE: dev
  rules:
    - if: '$CI_COMMIT_BRANCH == "development"'
    - if: '$CI_COMMIT_BRANCH == "live" && $DEPLOY_TO_DEV == "true"'

# Stage Site Template (live branch → WEBCMS_SITE: stage)
# Deploys to stage site from live branch for final testing before production.
# Supports both English and Spanish languages.
.deploy:staging:
  extends: .deploy
  variables:
    WEBCMS_ENVIRONMENT: preproduction  # AWS account tier (same as dev/production)
    WEBCMS_SITE: stage                 # Logical site identifier within environment
  rules:
    - if: '$CI_COMMIT_BRANCH == "live"'

# Kaniko Build Template (.kaniko)
# Base template for all Docker image builds using Kaniko (GitLab-compatible Docker builder)
# Configures ECR authentication and layer caching for efficient builds
# Includes caching for Composer dependencies to speed up PHP builds
.kaniko:
  image:
    name: registry.epa.gov/dso/infra/kaniko-executor:debug
    entrypoint: ['']

  variables:
    KANIKO_CACHE_ARGS: --cache --cache-repo=$WEBCMS_REPO_URL/webcms-$WEBCMS_ENVIRONMENT-cache

  # Cache Composer dependencies and other build artifacts
  # This significantly speeds up subsequent builds by reusing downloaded packages
  cache:
    key: composer-$CI_COMMIT_REF_SLUG
    paths:
      - services/drupal/vendor/
      - services/drupal/composer.lock
    policy: pull-push  # Allow cache population on first build, reuse on subsequent builds

  before_script:
    - mkdir -p /kaniko/.docker
    - echo '{"credsStore":"ecr-login"}' >/kaniko/.docker/config.json
    - echo $WEBCMS_REPO_URL/webcms-$WEBCMS_ENVIRONMENT-$WEBCMS_SITE-$WEBCMS_TARGET:$WEBCMS_IMAGE_TAG

#endregion

#region Image Builds
# Docker image build jobs using Kaniko (rootless, GitLab-compatible Docker builder).
# Builds application containers and mirrors third-party images to ECR.

# Drupal Application Build Job
# Builds the main Drupal application container with PHP-FPM
# Uses matrix build to create multiple variants (drupal, nginx, drush)
# Only runs when relevant Drupal files change to optimize build times
# Development branch builds - only dev site
build:drupal:dev:
  extends: .kaniko
  stage: Build
  rules:
    # Skip build entirely if SKIP_BUILD=true (reuse :development-latest images)
    - if: '$CI_COMMIT_BRANCH == "development" && $SKIP_BUILD == "true"'
      when: never
    - if: '$CI_COMMIT_BRANCH == "development"'
      when: always
    - when: never
  parallel:
    matrix:
      - WEBCMS_SITE: dev
        WEBCMS_TARGET: [drupal, nginx, drush]
  variables:
    WEBCMS_ENVIRONMENT: preproduction
  before_script:
    - mkdir -p /kaniko/.docker
    - echo '{"credsStore":"ecr-login"}' >/kaniko/.docker/config.json
    - echo $WEBCMS_REPO_URL/webcms-$WEBCMS_ENVIRONMENT-$WEBCMS_SITE-$WEBCMS_TARGET:$WEBCMS_IMAGE_TAG
  script:
    # Copy Composer authentication credentials for private package access
    - cp $auth_json $CI_PROJECT_DIR/services/drupal/auth.json
    # Enhanced caching and tag :development-latest for reuse in skip-build mode
    - /kaniko/executor
      $KANIKO_CACHE_ARGS
      --skip-unused-stages
      --snapshotMode=redo
      --use-new-run
      --cache-ttl=168h
      --cache-copy-layers=true
      --context=$CI_PROJECT_DIR/services/drupal
      --build-arg GIT_COMMIT=$CI_COMMIT_SHA
      --build-arg GIT_TAG=$CI_COMMIT_TAG
      --target=$WEBCMS_TARGET
      --destination=$WEBCMS_REPO_URL/webcms-$WEBCMS_ENVIRONMENT-$WEBCMS_SITE-$WEBCMS_TARGET:$WEBCMS_IMAGE_TAG
      --destination=$WEBCMS_REPO_URL/webcms-$WEBCMS_ENVIRONMENT-$WEBCMS_SITE-$WEBCMS_TARGET:development-latest
      --destination=$CI_REGISTRY_IMAGE/webcms-$WEBCMS_ENVIRONMENT-$WEBCMS_SITE-$WEBCMS_TARGET:$WEBCMS_IMAGE_TAG

# Live branch builds - stage (and optionally dev)
# By default only builds stage, set DEPLOY_TO_DEV=true to also build dev
build:drupal:stage:
  extends: .kaniko
  stage: Build
  rules:
    - if: '$CI_COMMIT_BRANCH == "live"'
      when: always
    - if: '$CI_COMMIT_TAG'
      variables:
        WEBCMS_IMAGE_TAG: $CI_COMMIT_TAG
      when: always
    - when: never
  parallel:
    matrix:
      - WEBCMS_SITE: stage
        WEBCMS_TARGET: [drupal, nginx, drush]
      - WEBCMS_SITE: dev
        WEBCMS_TARGET: [drupal, nginx, drush]
        DEPLOY_TO_DEV_REQUIRED: "true"  # This job only runs if DEPLOY_TO_DEV=true
  variables:
    WEBCMS_ENVIRONMENT: preproduction
  before_script:
    # Skip dev builds unless DEPLOY_TO_DEV=true
    - |
      if [ "$DEPLOY_TO_DEV_REQUIRED" = "true" ] && [ "$DEPLOY_TO_DEV" != "true" ]; then
        echo "Skipping dev build (DEPLOY_TO_DEV=${DEPLOY_TO_DEV})"
        exit 0
      fi
    - mkdir -p /kaniko/.docker
    - echo '{"credsStore":"ecr-login"}' >/kaniko/.docker/config.json
    - echo $WEBCMS_REPO_URL/webcms-$WEBCMS_ENVIRONMENT-$WEBCMS_SITE-$WEBCMS_TARGET:$WEBCMS_IMAGE_TAG
  script:
    - cp $auth_json $CI_PROJECT_DIR/services/drupal/auth.json
    - /kaniko/executor
      $KANIKO_CACHE_ARGS
      --skip-unused-stages
      --snapshotMode=redo
      --use-new-run
      --context=$CI_PROJECT_DIR/services/drupal
      --build-arg GIT_COMMIT=$CI_COMMIT_SHA
      --build-arg GIT_TAG=$CI_COMMIT_TAG
      --target=$WEBCMS_TARGET
      --destination=$WEBCMS_REPO_URL/webcms-$WEBCMS_ENVIRONMENT-$WEBCMS_SITE-$WEBCMS_TARGET:$WEBCMS_IMAGE_TAG
      --destination=$CI_REGISTRY_IMAGE/webcms-$WEBCMS_ENVIRONMENT-$WEBCMS_SITE-$WEBCMS_TARGET:$WEBCMS_IMAGE_TAG

#endregion

#region Prisma Cloud Image Scanning
# Scan Docker images for vulnerabilities using Prisma Cloud (Twistlock)
# These jobs pull images from GitLab registry and scan them using twistcli
# Only runs on live branch (stage deployments)

Prisma:Drupal:
  stage: Scan
  tags:
    - twistcli  # Requires runner with Docker and twistcli support
  needs:
    - job: "build:drupal:stage"
      optional: true  # Run even if build skipped (for tagged releases)
  rules:
    - if: '$CI_COMMIT_TAG'  # Run on tagged releases
      variables:
        WEBCMS_IMAGE_TAG: $CI_COMMIT_TAG  # Use tag as image tag
    - if: '$CI_COMMIT_BRANCH == "live"'  # Run on live branch only
  parallel:
    matrix:
      - WEBCMS_SITE: [stage]  # Scan stage site only (not dev)
  variables:
    GIT_STRATEGY: none  # Don't clone repo (only need to pull Docker image)
    WEBCMS_ENVIRONMENT: preproduction
  script:
    # Download twistcli scanner from Prisma Cloud using pre-provisioned token
    - 'curl --progress-bar -L -k --header "Authorization: Bearer $PRISMA_TOKEN" https://prismacloud.epa.gov/api/v1/util/twistcli > twistcli; chmod a+x twistcli;'
    # Login to GitLab container registry to pull the image for scanning
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
    - docker pull $CI_REGISTRY_IMAGE/webcms-${WEBCMS_ENVIRONMENT}-${WEBCMS_SITE}-drupal:$WEBCMS_IMAGE_TAG
    # Scan image for vulnerabilities and send results to Prisma Cloud
    - ./twistcli images scan $CI_REGISTRY_IMAGE/webcms-${WEBCMS_ENVIRONMENT}-${WEBCMS_SITE}-drupal:$WEBCMS_IMAGE_TAG --address=https://prismacloud.epa.gov --details --token=$PRISMA_TOKEN
  allow_failure: true

Prisma:Nginx:
  stage: Scan
  tags:
    - twistcli
  needs:
    - job: "build:drupal:stage"
      optional: true
  rules:
    - if: '$CI_COMMIT_TAG'
      variables:
        WEBCMS_IMAGE_TAG: $CI_COMMIT_TAG
    - if: '$CI_COMMIT_BRANCH == "live"'  # Run on live branch only
  parallel:
    matrix:
      - WEBCMS_SITE: [stage]  # Scan stage site only (not dev)
  variables:
    GIT_STRATEGY: none  # Don't clone repo (only need to pull Docker image)
    WEBCMS_ENVIRONMENT: preproduction
  script:
    # Download twistcli scanner from Prisma Cloud using pre-provisioned token
    - 'curl --progress-bar -L -k --header "Authorization: Bearer $PRISMA_TOKEN" https://prismacloud.epa.gov/api/v1/util/twistcli > twistcli; chmod a+x twistcli;'
    # Login to GitLab container registry to pull the image for scanning
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
    - docker pull $CI_REGISTRY_IMAGE/webcms-${WEBCMS_ENVIRONMENT}-${WEBCMS_SITE}-nginx:$WEBCMS_IMAGE_TAG
    # Scan image for vulnerabilities and send results to Prisma Cloud
    - ./twistcli images scan $CI_REGISTRY_IMAGE/webcms-${WEBCMS_ENVIRONMENT}-${WEBCMS_SITE}-nginx:$WEBCMS_IMAGE_TAG --address=https://prismacloud.epa.gov --details --token=$PRISMA_TOKEN
  allow_failure: true  # Don't block pipeline on scan failures

Prisma:Drush:
  stage: Scan
  tags:
    - twistcli
  needs:
    - job: "build:drupal:stage"
      optional: true
  rules:
    - if: '$CI_COMMIT_TAG'
      variables:
        WEBCMS_IMAGE_TAG: $CI_COMMIT_TAG
    - if: '$CI_COMMIT_BRANCH == "live"'  # Run on live branch only
  parallel:
    matrix:
      - WEBCMS_SITE: [stage]  # Scan stage site only (not dev)
  variables:
    GIT_STRATEGY: none  # Don't clone repo (only need to pull Docker image)
    WEBCMS_ENVIRONMENT: preproduction
  script:
    # Download twistcli scanner from Prisma Cloud using pre-provisioned token
    - 'curl --progress-bar -L -k --header "Authorization: Bearer $PRISMA_TOKEN" https://prismacloud.epa.gov/api/v1/util/twistcli > twistcli; chmod a+x twistcli;'
    # Login to GitLab container registry to pull the image for scanning
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
    - docker pull $CI_REGISTRY_IMAGE/webcms-${WEBCMS_ENVIRONMENT}-${WEBCMS_SITE}-drush:$WEBCMS_IMAGE_TAG
    # Scan image for vulnerabilities and send results to Prisma Cloud
    - ./twistcli images scan $CI_REGISTRY_IMAGE/webcms-${WEBCMS_ENVIRONMENT}-${WEBCMS_SITE}-drush:$WEBCMS_IMAGE_TAG --address=https://prismacloud.epa.gov --details --token=$PRISMA_TOKEN
  allow_failure: true  # Don't block pipeline on scan failures

#endregion

#region Preproduction AWS Account

# Preproduction AWS Account Jobs
# These jobs manage infrastructure and application deployments in the preproduction AWS account.
# This account hosts multiple logical environments: development site, staging site, and production (dev) site.
# All share WEBCMS_ENVIRONMENT=preproduction but differ by WEBCMS_SITE variable.

# Infrastructure Provisioning Jobs (live branch only)
# Creates/updates shared AWS resources: VPC, ECS cluster, load balancers, S3 buckets, etc.
infrastructure:preproduction:init:
  extends: .infrastructure
  stage: Infrastructure:Preprod:Init
  rules:
    - if: '$CI_COMMIT_BRANCH == "live"'  # Only run on live branch (production deployments)
  variables:
    WEBCMS_ENVIRONMENT: preproduction
    TF_STATE_NAME: dev  # Shared state for preproduction infrastructure
  script:
    - gitlab-terraform init -upgrade  # Upgrade providers to match lock file
    - gitlab-terraform init           # Initialize backend and download providers
  environment:
    name: infra/preproduction

infrastructure:preproduction:validate:
  extends: .infrastructure
  stage: Infrastructure:Preprod:Validate
  needs: ["infrastructure:preproduction:init"]  # Wait for init to complete
  rules:
    - if: '$CI_COMMIT_BRANCH == "live"'  # Only run on live branch
  variables:
    WEBCMS_ENVIRONMENT: preproduction
    TF_STATE_NAME: dev
  script:
    - gitlab-terraform validate  # Validate configuration syntax
  environment:
    name: infra/preproduction

infrastructure:preproduction:plan:
  extends: .infrastructure
  stage: Infrastructure:Preprod:Plan
  needs: ["infrastructure:preproduction:validate"]  # Wait for validation to pass
  rules:
    - if: '$CI_COMMIT_BRANCH == "live"'  # Only run on live branch
  variables:
    WEBCMS_ENVIRONMENT: preproduction
    TF_STATE_NAME: dev
  script:
    - gitlab-terraform plan       # Generate execution plan
    - gitlab-terraform plan-json  # Generate JSON for GitLab MR widget
  timeout: 24h  # Long timeout for complex infrastructure planning
  environment:
    name: infra/preproduction
  artifacts:
    name: terraform-plan-infrastructure-${WEBCMS_SITE}-${CI_COMMIT_SHORT_SHA}
    paths:
      - $TF_ROOT/plan.cache  # Binary plan used by apply job
    reports:
      terraform: $TF_ROOT/plan.json  # Displayed in GitLab merge request
    expire_in: 7 days  # Infrastructure plans need review before manual approval

infrastructure:preproduction:apply:
  extends: .infrastructure
  stage: Infrastructure:Preprod:Apply
  needs: ["infrastructure:preproduction:plan"]         # Wait for plan to complete
  dependencies: ["infrastructure:preproduction:plan"]  # Download plan.cache artifact
  rules:
    - if: '$CI_COMMIT_BRANCH == "live"'  # Only run on live branch
  variables:
    WEBCMS_ENVIRONMENT: preproduction
    TF_STATE_NAME: dev
  script:
    - gitlab-terraform apply  # Execute the cached plan
  environment:
    name: infra/preproduction

#endregion

#region Dev Site Deployment Jobs (development branch → WEBCMS_SITE: dev)
# Deploys application to dev site (English only, Spanish disabled)
# Uses resource groups to prevent concurrent deployments to same site/language

# Initialize Terraform for dev site deployments
deploy:dev:init:en:
  extends: .deploy:production
  stage: Deploy:Dev:Init
  variables:
    WEBCMS_LANG: en
    TF_STATE_NAME: dev-webcms-$WEBCMS_LANG
  resource_group: site/dev-$WEBCMS_LANG  # Prevent concurrent operations on this site/language
  environment:
    name: site/dev-$WEBCMS_LANG
  before_script:
    - cd $TF_ROOT
    - cp $backend_tf backend.tf
    - cp "$TERRAFORM_TFVARS" terraform.tfvars
    # Override image tag when SKIP_BUILD=true to use stable :development-latest tag
    - |
      if [ "$SKIP_BUILD" = "true" ]; then
        export TF_VAR_image_tag="development-latest"
        echo "ℹ️ SKIP_BUILD enabled - using image tag: development-latest"
      fi
  script:
    - echo $TF_ADDRESS  # Display state backend URL for debugging
    - gitlab-terraform init  # Initialize Terraform and download providers

# NOTE: Spanish (es) deployment for dev environment is disabled.
# This functionality is preserved for future use if needed.
# To re-enable, uncomment all dev-es jobs (init, validate, plan, apply).

# deploy:dev:init:es:
#   extends: .deploy:production
#   stage: Deploy:Dev:Init
#   variables:
#     WEBCMS_LANG: es
#     TF_STATE_NAME: dev-webcms-$WEBCMS_LANG
#   resource_group: site/dev-$WEBCMS_LANG  # Prevent concurrent operations on this site/language
#   environment:
#     name: site/dev-$WEBCMS_LANG
#   script:
#     - echo $TF_ADDRESS  # Display state backend URL for debugging
#     - gitlab-terraform init  # Initialize Terraform and download providers


# Validate Terraform configuration for dev site deployments
deploy:dev:validate:en:
  extends: .deploy:production
  stage: Deploy:Dev:Validate
  needs: ["deploy:dev:init:en"]  # Wait for init to complete
  variables:
    WEBCMS_LANG: en
    TF_STATE_NAME: dev-webcms-$WEBCMS_LANG
  environment:
    name: site/dev-$WEBCMS_LANG
  before_script:
    - cd $TF_ROOT
    - cp $backend_tf backend.tf
    - cp "$TERRAFORM_TFVARS" terraform.tfvars
    # Override image tag when SKIP_BUILD=true to use stable :development-latest tag
    - |
      if [ "$SKIP_BUILD" = "true" ]; then
        export TF_VAR_image_tag="development-latest"
        echo "ℹ️ SKIP_BUILD enabled - using image tag: development-latest"
      fi
  script:
    - gitlab-terraform validate

# Spanish validation job - disabled (see note above deploy:dev:init:es)
# deploy:dev:validate:es:
#   extends: .deploy:production
#   stage: Deploy:Dev:Validate
#   needs:
#     - job: "deploy:dev:init:es"
#       optional: true
#   variables:
#     WEBCMS_LANG: es
#     TF_STATE_NAME: dev-webcms-$WEBCMS_LANG
#   environment:
#     name: site/dev-$WEBCMS_LANG
#   script:
#     - gitlab-terraform validate

# Generate Terraform plans for dev site deployments
# Plan-json is skipped for dev to save time (only needed for MR review)
deploy:dev:plan-en:
  extends: .deploy:production
  stage: Deploy:Dev:Plan
  needs:
    - job: "deploy:dev:init:en"
      optional: true
    - job: "deploy:dev:validate:en"
      optional: true
  variables:
    WEBCMS_LANG: en
    TF_STATE_NAME: dev-webcms-$WEBCMS_LANG
  resource_group: site/dev-$WEBCMS_LANG  # Prevents concurrent plan/apply to same site/language
  environment:
    name: site/dev-$WEBCMS_LANG
  before_script:
    - cd $TF_ROOT
    - cp $backend_tf backend.tf
    - cp "$TERRAFORM_TFVARS" terraform.tfvars
    # Override image tag when SKIP_BUILD=true to use stable :development-latest tag
    - |
      if [ "$SKIP_BUILD" = "true" ]; then
        export TF_VAR_image_tag="development-latest"
        echo "ℹ️ SKIP_BUILD enabled - using image tag: development-latest"
      fi
  script:
    - gitlab-terraform plan       # Generate execution plan only (skip json for speed)
  artifacts:
    name: terraform-plan-webcms-${WEBCMS_SITE}-en-${CI_COMMIT_SHORT_SHA}
    paths:
      - $TF_ROOT/plan.cache  # Binary plan used by apply job
    expire_in: 1 day  # Shorter retention for fast-moving dev deployments

# Spanish plan job - disabled (see note above deploy:dev:init:es)
# deploy:dev:plan-es:
#   extends: .deploy:production
#   stage: Deploy:Dev:Plan
#   needs:
#     - job: "deploy:dev:validate:es"
#       optional: true
#   variables:
#     WEBCMS_LANG: es
#     TF_STATE_NAME: dev-webcms-$WEBCMS_LANG
#   resource_group: site/dev-$WEBCMS_LANG  # Prevents concurrent plan/apply to same site/language
#   environment:
#     name: site/dev-$WEBCMS_LANG
#   script:
#     - gitlab-terraform plan       # Generate execution plan
#     - gitlab-terraform plan-json  # Generate JSON for GitLab MR widget
#   artifacts:
#     name: terraform-plan-webcms-${WEBCMS_SITE}-es-${CI_COMMIT_SHORT_SHA}
#     paths:
#       - $TF_ROOT/plan.cache  # Binary plan used by apply job
#     reports:
#       terraform: $TF_ROOT/plan.json  # Displayed in GitLab merge request
#     expire_in: 3 days  # Short retention; deployment plans applied quickly after approval


# Apply Terraform plans for dev site deployments
# Optimized for speed: parallel execution where safe
deploy:dev:apply-en:
  extends: .deploy:production
  stage: Deploy:Dev:Apply
  needs:
    - job: "deploy:dev:plan-en"
      artifacts: true  # Download plan.cache
    - job: "build:drupal:dev"
      artifacts: false  # Don't wait for build artifacts
      optional: true
    - job: "build:drupal:stage"  # For live branch builds
      artifacts: false
      optional: true
  dependencies: ["deploy:dev:plan-en"]  # Download plan.cache artifact only
  variables:
    WEBCMS_LANG: en
    TF_STATE_NAME: dev-webcms-$WEBCMS_LANG
  before_script:
    - cd $TF_ROOT
    - cp $backend_tf backend.tf
    - cp "$TERRAFORM_TFVARS" terraform.tfvars
    # Override image tag when SKIP_BUILD=true to use stable :development-latest tag
    - |
      if [ "$SKIP_BUILD" = "true" ]; then
        export TF_VAR_image_tag="development-latest"
        echo "ℹ️ SKIP_BUILD enabled - using image tag: development-latest"
      else
        export TF_VAR_image_tag="$WEBCMS_IMAGE_TAG"
        echo "ℹ️ Using commit-specific image tag: $WEBCMS_IMAGE_TAG"
      fi
  resource_group: site/dev-$WEBCMS_LANG  # Prevent concurrent apply operations to same site/language
  environment:
    name: site/dev-$WEBCMS_LANG
  script:
    - gitlab-terraform apply  # Execute the cached plan
  # Deployment rules for dev site
  rules:
    # Infrastructure changes require manual approval
    - if: >-
        $TF_MODULE == "infrastructure" &&
        $CI_COMMIT_BRANCH == "development"
      when: manual
    # Development branch: automatic deployment for application updates
    - if: >-
        $TF_MODULE == "webcms" &&
        $CI_COMMIT_BRANCH == "development"
      when: on_success
    # Live branch: manual deployment when DEPLOY_TO_DEV=true
    - if: >-
        $TF_MODULE == "webcms" &&
        $CI_COMMIT_BRANCH == "live" &&
        $DEPLOY_TO_DEV == "true"
      when: manual
    - when: never       # Deny all other scenarios

# Spanish apply job - disabled (see note above deploy:dev:init:es)
# deploy:dev:apply-es:
#   extends: .deploy:production
#   stage: Deploy:Dev:Apply
#   needs:
#     - job: "deploy:dev:plan-es"
#       optional: true  # Allow manual plan triggering
#     - job: "build:drupal"
#       optional: true  # Images may already exist from prior builds
#   dependencies: ["deploy:dev:plan-es"]  # Download plan.cache artifact only (not build artifacts)
#   variables:
#     WEBCMS_LANG: es
#     TF_STATE_NAME: dev-webcms-$WEBCMS_LANG
#   resource_group: site/dev-$WEBCMS_LANG  # Prevent concurrent apply operations to same site/language
#   environment:
#     name: site/dev-$WEBCMS_LANG
#   script:
#     - gitlab-terraform apply  # Execute the cached plan
#   # Require manual approval for all production deployments
#   rules:
#     # Skip if WEBCMS_SITE_FILTER is set to something other than dev
#     - if: '$WEBCMS_SITE_FILTER && $WEBCMS_SITE_FILTER != "dev"'
#       when: never
#     - if: >-
#         $TF_MODULE == "infrastructure" &&
#         ($CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "live")
#       when: manual      # Require approval for VPC, ECS cluster, load balancer changes
#     - if: >-
#         $TF_MODULE == "webcms" &&
#         ($CI_COMMIT_BRANCH == "integration" || $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "live")
#       when: manual      # Require manual approval for all production deployments
#     - when: never       # Deny all other scenarios

#endregion

#region Stage Site Deployment (live branch → WEBCMS_SITE: stage)
# Deploys to stage site from live branch for final testing before production
# Supports both English and Spanish languages with parallel matrix builds

# Initialize Terraform for stage site deployments
deploy:stage:init-en:
  extends: .deploy:staging
  stage: Deploy:Stage:Init
  variables:
    WEBCMS_LANG: en
    TF_STATE_NAME: stage-webcms-$WEBCMS_LANG
  resource_group: site/stage-$WEBCMS_LANG  # Prevent concurrent operations on this site/language
  environment:
    name: site/stage-$WEBCMS_LANG
  script:
    - gitlab-terraform init  # Initialize Terraform and download providers

deploy:stage:init-es:
  extends: .deploy:staging
  stage: Deploy:Stage:Init
  variables:
    WEBCMS_LANG: es
    TF_STATE_NAME: stage-webcms-$WEBCMS_LANG
  resource_group: site/stage-$WEBCMS_LANG  # Prevent concurrent operations on this site/language
  environment:
    name: site/stage-$WEBCMS_LANG
  script:
    - gitlab-terraform init  # Initialize Terraform and download providers

deploy:stage:validate-en:
  extends: .deploy:staging
  stage: Deploy:Stage:Validate
  needs:
    - job: "deploy:stage:init-en"
      optional: true
  variables:
    WEBCMS_LANG: en
    TF_STATE_NAME: stage-webcms-$WEBCMS_LANG
  resource_group: site/stage-$WEBCMS_LANG
  environment:
    name: site/stage-$WEBCMS_LANG
  script:
    - gitlab-terraform validate

deploy:stage:validate-es:
  extends: .deploy:staging
  stage: Deploy:Stage:Validate
  needs:
    - job: "deploy:stage:init-es"
      optional: true
  variables:
    WEBCMS_LANG: es
    TF_STATE_NAME: stage-webcms-$WEBCMS_LANG
  resource_group: site/stage-$WEBCMS_LANG
  environment:
    name: site/stage-$WEBCMS_LANG
  script:
    - gitlab-terraform validate

deploy:stage:plan-en:
  extends: .deploy:staging
  stage: Deploy:Stage:Plan
  needs:
    - job: "deploy:stage:validate-en"
      optional: true  # Allow manual validation triggering
  variables:
    WEBCMS_LANG: en
    TF_STATE_NAME: stage-webcms-$WEBCMS_LANG
  resource_group: site/stage-$WEBCMS_LANG  # Prevent concurrent plan/apply to same site/language
  environment:
    name: site/stage-$WEBCMS_LANG
  script:
    - gitlab-terraform plan       # Generate execution plan
    - gitlab-terraform plan-json  # Generate JSON for GitLab MR widget
  artifacts:
    name: terraform-plan-webcms-${WEBCMS_SITE}-en-${CI_COMMIT_SHORT_SHA}
    paths:
      - $TF_ROOT/plan.cache  # Binary plan used by apply job
    reports:
      terraform: $TF_ROOT/plan.json  # Displayed in GitLab merge request
    expire_in: 3 days  # Match dev deployment retention policy

deploy:stage:plan-es:
  extends: .deploy:staging
  stage: Deploy:Stage:Plan
  needs:
    - job: "deploy:stage:validate-es"
      optional: true  # Allow manual validation triggering
  variables:
    WEBCMS_LANG: es
    TF_STATE_NAME: stage-webcms-$WEBCMS_LANG
  resource_group: site/stage-$WEBCMS_LANG  # Prevent concurrent plan/apply to same site/language
  environment:
    name: site/stage-$WEBCMS_LANG
  script:
    - gitlab-terraform plan       # Generate execution plan
    - gitlab-terraform plan-json  # Generate JSON for GitLab MR widget
  artifacts:
    name: terraform-plan-webcms-${WEBCMS_SITE}-es-${CI_COMMIT_SHORT_SHA}
    paths:
      - $TF_ROOT/plan.cache  # Binary plan used by apply job
    reports:
      terraform: $TF_ROOT/plan.json  # Displayed in GitLab merge request
    expire_in: 3 days  # Match dev deployment retention policy

deploy:stage:apply-en:
  extends: .deploy:staging
  stage: Deploy:Stage:Apply
  needs:
    - job: "deploy:stage:plan-en"
      optional: true  # Allow manual plan triggering
    - job: "build:drupal:stage"
      optional: true  # Images may already exist from prior builds
  dependencies: ["deploy:stage:plan-en"]  # Download plan.cache artifact only (not build artifacts)
  variables:
    WEBCMS_LANG: en
    TF_STATE_NAME: stage-webcms-$WEBCMS_LANG
  resource_group: site/stage-$WEBCMS_LANG  # Prevent concurrent apply operations to same site/language
  environment:
    name: site/stage-$WEBCMS_LANG
  script:
    - gitlab-terraform apply  # Execute the cached plan
  # Temporary: Require manual approval for staging deployments during initial AWS testing
  when: manual

deploy:stage:apply-es:
  extends: .deploy:staging
  stage: Deploy:Stage:Apply
  needs:
    - job: "deploy:stage:plan-es"
      optional: true  # Allow manual plan triggering
    - job: "build:drupal:stage"
      optional: true  # Images may already exist from prior builds
  dependencies: ["deploy:stage:plan-es"]  # Download plan.cache artifact only (not build artifacts)
  variables:
    WEBCMS_LANG: es
    TF_STATE_NAME: stage-webcms-$WEBCMS_LANG
  resource_group: site/stage-$WEBCMS_LANG  # Prevent concurrent apply operations to same site/language
  environment:
    name: site/stage-$WEBCMS_LANG
  script:
    - gitlab-terraform apply  # Execute the cached plan
  # Temporary: Require manual approval for staging deployments during initial AWS testing
  when: manual

#endregion

#region Database Update Jobs (Drush Operations)
# These jobs run after deployment to apply database schema updates and clear caches
# They use ECS tasks to execute Drush commands in the deployed environment
# Resource groups prevent overlapping Drush operations on the same site/language

update:stage:en:
  extends: .update
  stage: Update
  needs:
    - job: "deploy:stage:apply-en"
      optional: true
  rules:
    - if: '$WEBCMS_SITE_FILTER && $WEBCMS_SITE_FILTER != "stage"'
      when: never
    - if: '$CI_COMMIT_BRANCH == "live"'

  variables:
    WEBCMS_ENVIRONMENT: preproduction
    WEBCMS_SITE: stage
    WEBCMS_LANG: en

  # Resource group prevents overlapping Drush operations on the same site
  # Environment tracking enables deployment status visibility
  resource_group: drush/stage-en
  environment:
    name: site/stage-en

update:stage:es:
  extends: .update
  stage: Update
  needs:
    - job: "deploy:stage:apply-es"
      optional: true
  rules:
    - if: '$CI_COMMIT_BRANCH == "live"'

  variables:
    WEBCMS_ENVIRONMENT: preproduction
    WEBCMS_SITE: stage
    WEBCMS_LANG: es

  # Resource group prevents overlapping Drush operations on the same site
  # Environment tracking enables deployment status visibility
  resource_group: drush/stage-es
  environment:
    name: site/stage-es
update:dev:en:
  extends: .update
  stage: Update
  needs:
    - job: "deploy:dev:apply-en"
      optional: true
  rules:
    - if: '$CI_COMMIT_BRANCH == "development"'

  variables:
    WEBCMS_ENVIRONMENT: preproduction
    WEBCMS_SITE: dev
    WEBCMS_LANG: en

  # Resource group prevents overlapping Drush operations on the same site
  # Environment tracking enables deployment status visibility
  resource_group: drush/dev-$WEBCMS_LANG
  environment:
    name: site/dev-$WEBCMS_LANG
  # Require manual approval for production database updates
  when: manual

# NOTE: Spanish (es) deployment for dev environment is disabled.
# This update job is commented out to match the disabled deploy:dev:apply-es job.
# To re-enable, uncomment this job and the corresponding deploy jobs.

# update:dev:es:
#   extends: .update
#   stage: Update
#   needs:
#     - job: "deploy:dev:apply-es"
#       optional: true
#   rules:
#     - if: '$CI_COMMIT_BRANCH == "development"'
#
#   variables:
#     WEBCMS_ENVIRONMENT: preproduction
#     WEBCMS_SITE: dev
#     WEBCMS_LANG: es
#
#   # Resource group prevents overlapping Drush operations on the same site
#   # Environment tracking enables deployment status visibility
#   resource_group: drush/dev-$WEBCMS_LANG
#   environment:
#     name: site/dev-$WEBCMS_LANG
#   # Require manual approval for production database updates
#   when: manual

#endregion

###################
# Create Releases #
###################

# Create deployment artifacts for rollback and external deployments
artifacts:
  image: alpine  # Minimal image sufficient for file packaging
  stage: Artifacts
  rules:
    - if: '$CI_COMMIT_BRANCH == "development"'  # Skip on development branch
      when: never
    - if: $CI_COMMIT_TAG != ""  # Run on tagged releases
      when: always
    - if: '$CI_COMMIT_BRANCH == "live"'  # Run on live branch deployments
      when: always
    - when: never  # Don't run on any other branches
  script:
    - echo "Creating release artifacts for ${CI_COMMIT_REF_NAME}"
  artifacts:
    name: release-artifacts-${CI_COMMIT_REF_NAME}-${CI_COMMIT_SHORT_SHA}
    paths:
      - ./ci                        # Drush automation scripts
      - ./terraform/infrastructure  # Infrastructure Terraform configs
      - ./terraform/webcms          # Application Terraform configs
    expire_in: 30 days  # Keep longer for rollback scenarios

